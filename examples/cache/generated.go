// The cache command was automatically generated by Shenzhen Go.
package main

import (
	"fmt"
	"math/rand"
	"runtime"
	"sync"
	"time"
)

var _ = runtime.Compiler

func Cache(get <-chan struct {
	Key int
	Ctx struct{}
}, hit chan<- struct {
	Key  int
	Ctx  struct{}
	Data []byte
}, miss chan<- struct {
	Key int
	Ctx struct{}
}, put <-chan struct {
	Key  int
	Data []byte
}) {
	// Cache
	multiplicity := runtime.NumCPU()

	const bytesLimit = 1048576
	type cacheEntry struct {
		data []byte
		last time.Time
		sync.Mutex
	}
	var mu sync.RWMutex
	totalBytes := uint64(0)
	cache := make(map[int]*cacheEntry)

	defer func() {
		close(hit)
		close(miss)
	}()
	var multWG sync.WaitGroup
	multWG.Add(multiplicity)
	defer multWG.Wait()
	for n := 0; n < multiplicity; n++ {
		go func() {
			defer multWG.Done()

		handleLoop:
			for {
				select {
				case g, open := <-get:
					if !open {
						break handleLoop
					}
					mu.RLock()
					e, ok := cache[g.Key]
					mu.RUnlock()
					if !ok {
						miss <- g

						continue
					}
					e.Lock()
					hit <- struct {
						Key  int
						Ctx  struct{}
						Data []byte
					}{
						Key:  g.Key,
						Ctx:  g.Ctx,
						Data: e.data,
					}
					e.last = time.Now()
					e.Unlock()

				case p, open := <-put:
					if !open {
						put = nil
						continue
					}
					if len(p.Data) > bytesLimit {
						continue
					}

					// TODO: Can improve eviction algorithm - this is simplistic but O(n^2)
					mu.Lock()
					for {
						// Find something to evict if needed.
						var ek int
						var ee *cacheEntry
						et := time.Now()
						for k, e := range cache {
							e.Lock()
							if e.last.Before(et) {
								ee, et, ek = e, e.last, k
							}
							e.Unlock()
						}
						// Necessary to evict?
						if totalBytes+uint64(len(p.Data)) > bytesLimit {
							// Evict ek.
							if ee == nil {
								break
							}
							ee.Lock()
							size := uint64(len(ee.data))
							ee.Unlock()
							totalBytes -= size
							delete(cache, ek)
							continue
						}

						// No - insert now.
						size := uint64(len(p.Data))
						cache[p.Key] = &cacheEntry{
							data: p.Data,
							last: time.Now(),
						}
						totalBytes += size
						break
					}
					mu.Unlock()
				}
			}
		}()
	}
}

func Get_random_items(keys chan<- struct {
	Key int
	Ctx struct{}
}) {
	// Get random items

	defer func() {
		close(keys)
	}()
	for i := 0; i < 200; i++ {
		keys <- struct {
			Key int
			Ctx struct{}
		}{
			Key: rand.Intn(6),
		}
	}
}

func Print_hits(gets <-chan struct {
	Key  int
	Ctx  struct{}
	Data []byte
}) {
	// Print hits

	for g := range gets {
		fmt.Printf("Hit: %v (ctx %v, size %v)\n", g.Key, g.Ctx, len(g.Data))
	}
}

func Print_misses(keys <-chan struct {
	Key int
	Ctx struct{}
}) {
	// Print misses

	for k := range keys {
		fmt.Printf("Miss: %v\n", k)
	}
}

func Put_random_sizes(puts chan<- struct {
	Key  int
	Data []byte
}) {
	// Put random sizes

	defer func() {
		close(puts)
	}()
	for i := 0; i < 6; i++ {
		puts <- struct {
			Key  int
			Data []byte
		}{
			Key: i,
			// Very large sizes to trigger evictions
			Data: make([]byte, rand.Intn(1<<19)),
		}
	}
}

func main() {

	channel0 := make(chan struct {
		Key int
		Ctx struct{}
	}, 0)
	channel1 := make(chan struct {
		Key  int
		Data []byte
	}, 0)
	channel2 := make(chan struct {
		Key int
		Ctx struct{}
	}, 0)
	channel3 := make(chan struct {
		Key  int
		Ctx  struct{}
		Data []byte
	}, 0)

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		Cache(channel0, channel3, channel2, channel1)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Get_random_items(channel0)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Print_hits(channel3)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Print_misses(channel2)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Put_random_sizes(channel1)
		wg.Done()
	}()

	// Wait for the various goroutines to finish.
	wg.Wait()
}
